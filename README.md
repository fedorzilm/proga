# База Данных Интернет-Провайдера - Этап 4: Клиент-Серверная Архитектура

## 1. Введение

Данный документ описывает реализацию Этапа 4 проекта "База Данных Интернет-Провайдера", доработанную с учетом требований к надежности, производительности и удобству использования. Целью этого этапа являлось преобразование ранее созданного консольного приложения для работы с базой данных в полноценную клиент-серверную систему. Это включает разделение логики на серверную часть (обработка запросов, управление БД) и клиентскую часть (отправка запросов, получение результатов), а также организацию их сетевого взаимодействия по протоколу TCP/IP.

Проект выполнен в соответствии с заданием №9 "Интернет провайдер" для 4-го семестра.

## 2. Отчет по Этапу 4 (в соответствии с требованиями task.pdf)

### 2.1. Описание структуры реализации клиента и сервера, выбранные сетевые протоколы, способы передачи данных и проверки каналов обмена

#### 2.1.1. Общая архитектура
Система разделена на два основных компонента:
* **Сервер (`database_server`):** Приложение, отвечающее за хранение, управление базой данных (`Database`) и тарифным планом (`TariffPlan`), а также за обработку запросов от клиентов.
* **Клиент (`database_client`):** Консольное приложение, предоставляющее пользователю интерфейс для взаимодействия с сервером.

#### 2.1.2. Сервер (`database_server`)
* **Назначение:** Основная задача сервера – прием запросов от клиентов, их обработка (включая операции с базой данных и расчеты) и отправка результатов обратно клиентам.
* **Ключевые компоненты и их взаимодействие:**
    * `ServerConfig` (`server_config.h/.cpp`): Управляет конфигурационными параметрами сервера (порт, путь к файлу тарифов, базовая директория для данных сервера, уровень и файл логирования, размер пула потоков). Параметры загружаются из конфигурационного файла (`server.conf`, по умолчанию) и могут быть переопределены аргументами командной строки. Относительные пути к файлу тарифов, директории данных и файлу лога разрешаются относительно директории исполняемого файла сервера для удобства развертывания.
    * `TCPSocket` (`tcp_socket.h/.cpp`): Используется для создания слушающего TCP-сокета на указанном порту и для приема входящих клиентских соединений.
    * `ThreadPool` (`thread_pool.h/.cpp`): Для обработки каждого клиентского соединения используется пул рабочих потоков. Это позволяет серверу одновременно обслуживать несколько клиентов, повышая отзывчивость и производительность. Размер пула потоков настраивается через `ServerConfig`.
    * `Server` (`server.h/.cpp`): Центральный класс серверной части. Управляет жизненным циклом сервера, инициализирует слушающий сокет, запускает и останавливает `ThreadPool`, а также содержит главный поток-акцептор (`acceptorThreadLoop`), который принимает новые соединения и передает их на обработку в `ThreadPool`.
    * `ServerCommandHandler` (`server_command_handler.h/.cpp`): Экземпляр этого класса создается для каждой клиентской сессии (в рамках задачи в `ThreadPool`). Он инкапсулирует логику обработки всех типов команд, полученных от клиента. Взаимодействует с `QueryParser` для разбора строки запроса, с `Database` для выполнения операций с данными, и с `TariffPlan` для расчета начислений. Формирует текстовый ответ для клиента. Для операций `LOAD` и `SAVE` использует функцию `getSafeServerFilePath_SCH` для обеспечения безопасности файловых операций, ограничивая их специальной директорией (`server_databases` внутри базового пути данных сервера).
    * `Database` (`database.h/.cpp`): Ядро системы, хранит записи `ProviderRecord` в памяти (`std::vector`). Предоставляет методы для CRUD-операций, поиска, загрузки/сохранения из/в файл. Доступ к экземпляру `Database` из разных потоков `ThreadPool` синхронизирован с помощью `std::shared_mutex` (разделяемая блокировка для операций чтения, эксклюзивная – для операций записи), что обеспечивает целостность данных при параллельной обработке запросов.
    * `QueryParser` (`query_parser.h/.cpp`): Отвечает за разбор текстовых строк запросов, полученных от клиента, в структурированный объект `Query`.
    * `TariffPlan` (`tariff_plan.h/.cpp`): Хранит почасовые тарифные ставки, загружаемые из файла, и используется для расчета стоимости услуг.
    * `Logger` (`logger.h/.cpp`): Обеспечивает централизованное и потокобезопасное логирование работы всех компонентов сервера с настраиваемым уровнем детализации и выводом в консоль и/или файл.
* **Обработка сигналов и корректное завершение:** Сервер корректно обрабатывает сигналы `SIGINT` и `SIGTERM` (для POSIX-систем) и консольные управляющие события (для Windows) для штатного завершения работы. При получении такого сигнала устанавливается глобальный флаг `g_server_should_stop`, что приводит к закрытию слушающего сокета, остановке пула потоков (с ожиданием завершения текущих задач) и завершению потока-акцептора.

#### 2.1.3. Клиент (`database_client`)
* **Назначение:** Предоставляет пользователю возможность отправлять запросы на сервер и получать результаты.
* **Режимы работы:**
    * **Интерактивный режим:** Пользователь вводит команды в консоль. Поддерживаются локальные команды `HELP` (для справки по командам) и `QUIT_CLIENT` (для выхода из программы с уведомлением сервера).
    * **Пакетный режим:** Активируется опцией `-f <файл_запросов>`. Команды считываются из указанного файла, отправляются на сервер, а ответы сохраняются в выходной файл (имя по умолчанию формируется как `<имя_файла_запросов>.out.<расширение>` или указывается опцией `-o`). Пустые строки и строки, начинающиеся с `#` (комментарии) в файле команд, игнорируются.
* **Ключевые компоненты:**
    * `TCPSocket` (`tcp_socket.h/.cpp`): Используется для установления TCP-соединения с сервером и для обмена данными (отправка запросов, прием ответов).
    * `Logger` (`logger.h/.cpp`): Для логирования работы клиента с настраиваемым уровнем и файлом вывода.
* **Параметры запуска:** Принимает адрес сервера (`-s`, обязательный), порт (`-p`), путь к файлу команд (`-f`), путь к файлу вывода (`-o`), таймаут ожидания ответа от сервера (`--timeout`), а также настройки логирования (`-l`, `--log-file`).
* **Завершение сессии:** При выходе из клиента (команда `EXIT`, `QUIT_CLIENT`, `EOF` в интерактивном режиме, или по завершении пакетного файла) клиент отправляет серверу специальное уведомление `EXIT_CLIENT_SESSION` для корректного закрытия сессии на стороне сервера.

### 2.1.4. Сетевой протокол и передача данных (Обновлено для Этапа 4)

* **Протокол транспортного уровня:** Используется TCP/IP для обеспечения надежной доставки сообщений между клиентом и сервером.

* **Протокол прикладного уровня (обмен сообщениями):**
    * **Общий формат передачи**: Каждое логическое сообщение (будь то запрос от клиента, полный ответ от сервера или часть многочастного ответа) передается с использованием префикса длины. Сначала отправляется 4-байтовое целое число без знака (`uint32_t`) в сетевом порядке байт (big-endian), указывающее длину последующих данных сообщения в байтах. Затем передаются сами данные сообщения в виде текстовой строки (предположительно в кодировке UTF-8).
    * **Максимальный размер одного сообщения/чанка**: Для предотвращения чрезмерного использования ресурсов, размер полезной нагрузки одного передаваемого блока (не включая 4-байтовый префикс длины) ограничен константой `MAX_MESSAGE_PAYLOAD_SIZE` (текущее значение 1 МБ, определено в `src/common_defs.h`).
    * **Запросы от клиента**: Представляют собой текстовые строки команд, соответствующие языку запросов, разработанному на Этапе 3.
    * **Ответы от сервера (Структурированный формат с поддержкой чанкования)**:
        Ответы сервера имеют строго определенную структуру для обеспечения надежного парсинга на стороне клиента и для поддержки передачи больших объемов данных (чанкования). Каждое сообщение от сервера (даже если это часть многочастного ответа) начинается с текстового заголовка, за которым следует маркер начала данных (`--DATA_BEGIN--\n`) и затем сама полезная нагрузка.

        **Структура Заголовка Ответа Сервера:**
        ```
        STATUS: <Числовой Код Статуса>
        MESSAGE: <Текстовое Сообщение Статуса (может быть пустым)>
        RECORDS_IN_PAYLOAD: <Количество записей ProviderRecord в полезной нагрузке этого сообщения>
        TOTAL_RECORDS: <Общее количество записей ProviderRecord, если это начало многочастного ответа; иначе 0>
        PAYLOAD_TYPE: <Строковый тип полезной нагрузки>
        --DATA_BEGIN--
        ```

        **Ключевые поля заголовка (определены в `src/common_defs.h`):**
        * `STATUS` (`SRV_HEADER_STATUS`): Числовой код, указывающий результат операции. Основные значения:
            * `200 (SRV_STATUS_OK)`: Запрос успешно выполнен, ответ полный и содержится в данном сообщении (одночастный ответ).
            * `201 (SRV_STATUS_OK_MULTI_PART_BEGIN)`: Запрос успешно выполнен, начинается передача многочастного ответа. Поле `TOTAL_RECORDS` указывает общее число записей `ProviderRecord` во всех частях. Полезная нагрузка этого сообщения содержит первую часть (чанк) данных.
            * `202 (SRV_STATUS_OK_MULTI_PART_CHUNK)`: Очередной чанк данных многочастного ответа.
            * `203 (SRV_STATUS_OK_MULTI_PART_END)`: Завершение передачи многочастного ответа. Полезная нагрузка обычно отсутствует или содержит финальное сообщение.
            * `400 (SRV_STATUS_BAD_REQUEST)`: Сервер не смог обработать запрос из-за ошибки на стороне клиента (например, неверный синтаксис команды, некорректные параметры).
            * `404 (SRV_STATUS_NOT_FOUND)`: Запрошенные данные или ресурс не найдены на сервере.
            * `500 (SRV_STATUS_SERVER_ERROR)`: Произошла внутренняя ошибка на стороне сервера при обработке запроса.
        * `MESSAGE` (`SRV_HEADER_MESSAGE`): Человекочитаемое текстовое сообщение, поясняющее статус или содержащее дополнительную информацию от сервера.
        * `RECORDS_IN_PAYLOAD` (`SRV_HEADER_RECORDS_IN_PAYLOAD`): Указывает количество записей `ProviderRecord`, содержащихся в полезной нагрузке *текущего* сообщения/чанка. Для ответов, не содержащих список записей (например, тип `SIMPLE_MESSAGE` или `ERROR_INFO`), это значение может быть 0.
        * `TOTAL_RECORDS` (`SRV_HEADER_TOTAL_RECORDS`): Используется только в сообщении со статусом `SRV_STATUS_OK_MULTI_PART_BEGIN`. Информирует клиента об общем количестве записей `ProviderRecord`, которые будут переданы во всех последующих чанках этого многочастного ответа.
        * `PAYLOAD_TYPE` (`SRV_HEADER_PAYLOAD_TYPE`): Строка, идентифицирующая тип данных в полезной нагрузке. Основные типы:
            * `PROVIDER_RECORDS_LIST` (): Полезная нагрузка содержит список записей `ProviderRecord`.
            * `SIMPLE_MESSAGE` (): Полезная нагрузка содержит простое текстовое информационное сообщение (например, подтверждение выполнения команды `ADD`, `DELETE`).
            * `ERROR_INFO` (): Полезная нагрузка содержит детализированную информацию об ошибке.
            * `NONE` (): Полезная нагрузка отсутствует (например, для сообщения `SRV_STATUS_OK_MULTI_PART_END`).
        * `--DATA_BEGIN--` (`SRV_HEADER_DATA_MARKER`): Специальный маркер-строка, отделяющий блок заголовков от фактических данных полезной нагрузки.

        **Полезная нагрузка (`payload`) после маркера `--DATA_BEGIN--`:**
        * Для типа `PROVIDER_RECORDS_LIST`: Текстовое представление одной или нескольких записей `ProviderRecord`. Каждая запись форматируется согласно `ProviderRecord::operator<<`. Если в чанке несколько записей, они разделяются строкой `\n-----------------------------------------------------------------\n` (за исключением последней записи в чанке, после которой такой разделитель может отсутствовать, но всегда будет `\n` от `operator<<`).
        * Для типов `SIMPLE_MESSAGE` или `ERROR_INFO`: Текстовое сообщение, которое может быть многострочным.

        **Механизм Чанкования (Chunking) для Больших Ответов:**
        1.  Если сервер (`ServerCommandHandler`) определяет, что результат выполнения запроса (например, `PRINT_ALL` или `SELECT`) содержит большое количество записей (превышающее `SRV_CHUNKING_THRESHOLD_RECORDS`), он инициирует многочастный ответ.
        2.  **Первое сообщение (Начало многочастной передачи)**: Сервер отправляет сообщение с заголовком, где `STATUS: 201 (SRV_STATUS_OK_MULTI_PART_BEGIN)`. Поле `TOTAL_RECORDS` указывает общее число записей `ProviderRecord`, которые будут переданы. Полезная нагрузка этого первого сообщения содержит первый чанк данных (например, `SRV_DEFAULT_CHUNK_RECORDS_COUNT` записей).
        3.  **Последующие сообщения (Чанки данных)**: Если остались еще данные, сервер отправляет их порциями. Каждая такая порция является отдельным сообщением "длина + данные" и имеет заголовок со статусом `STATUS: 202 (SRV_STATUS_OK_MULTI_PART_CHUNK)`. Полезная нагрузка содержит очередной чанк записей.
        4.  **Завершающее сообщение**: После отправки всех данных (всех чанков) сервер посылает финальное сообщение с заголовком, где `STATUS: 203 (SRV_STATUS_OK_MULTI_PART_END)`. Полезная нагрузка этого сообщения обычно пуста (`PAYLOAD_TYPE: NONE`).
        5.  **Клиент (`client_main.cpp`)**: При получении ответа парсит заголовок. Если статус `SRV_STATUS_OK_MULTI_PART_BEGIN`, клиент запоминает `TOTAL_RECORDS` и входит в режим ожидания последующих чанков (со статусом `SRV_STATUS_OK_MULTI_PART_CHUNK`) до тех пор, пока не получит сообщение со статусом `SRV_STATUS_OK_MULTI_PART_END`. Клиент накапливает или обрабатывает данные из каждого чанка. Если общее количество полученных записей не совпадает с `TOTAL_RECORDS` после получения `SRV_STATUS_OK_MULTI_PART_END`, клиент выводит предупреждение.

* **Служебные сообщения клиента**:
    * `EXIT_CLIENT_SESSION`: Специальная строка, которую клиент может отправить серверу (также с префиксом длины) для немедленного уведомления о завершении сеанса со своей стороны (например, при `QUIT_CLIENT` или обработке `EOF`). Сервер, получив эту команду, просто завершает обработку для данного клиента без отправки ответа.

* **Реализация**: Низкоуровневая передача сообщений "длина + данные" инкапсулирована в классе `TCPSocket`. Логика формирования и разбора структурированных заголовков, а также управление чанкованием, реализованы в `ServerCommandHandler` на стороне сервера и в функции `process_single_request_to_server` в `client_main.cpp` на стороне клиента.

#### 2.1.5. Обоснование выбора архитектурных решений
* **Многопоточность на сервере (`ThreadPool`):** Модель с пулом потоков была выбрана как компромисс между простотой реализации и способностью обрабатывать несколько клиентов одновременно. Она позволяет избежать высоких накладных расходов, связанных с созданием нового потока для каждого соединения (как в модели "поток на клиента"), и при этом обеспечивает хороший параллелизм для большинства сценариев использования учебного проекта. Для задач с экстремально высоким количеством одновременных подключений (C10k+) более предпочтительной была бы асинхронная модель на основе неблокирующего ввода-вывода (например, с `epoll` или `IOCP`), однако ее реализация значительно сложнее и выходит за рамки текущих требований.
* **Протокол "длина + данные":** Этот протокол прост в реализации, эффективен для передачи текстовых сообщений переменной длины и не требует использования внешних библиотек для сериализации. Он решает основную проблему TCP – отсутствие явных границ сообщений в потоке. Альтернативы, такие как использование разделителей сообщений (например, `\n`), менее надежны, особенно если сами данные могут содержать эти разделители. Структурированные форматы (JSON, Protobuf) обеспечили бы лучшую типизацию, но усложнили бы парсинг и сериализацию на данном этапе.
* **Синхронизация доступа к `Database` (`std::shared_mutex`):** Выбор `std::shared_mutex` позволяет оптимизировать производительность при преобладании операций чтения, разрешая одновременный доступ нескольким потокам. Для операций записи используется эксклюзивная блокировка, гарантирующая целостность данных. Это стандартный и эффективный подход для подобных задач.

### 2.2. Описание логики взаимодействия клиента и сервера, какими сообщениями они обмениваются при обработке запроса и отправки ответа

1.  **Установка соединения:**
    * Клиент (`database_client`) инициирует TCP-соединение с сервером (`database_server`) по указанным адресу и порту.
    * Сервер (поток-акцептор в `Server::acceptorThreadLoop`) принимает новое соединение и передает объект `TCPSocket` для этого клиента в одну из задач `ThreadPool`.
2.  **Цикл обработки запросов (в рамках одной клиентской сессии):**
    * **Клиент:**
        1.  Формирует текстовую строку запроса (например, `SELECT FIO "Иванов" END`).
        2.  Отправляет запрос серверу, используя протокол "длина + данные" (`TCPSocket::sendAllDataWithLengthPrefix`).
        3.  Ожидает ответ от сервера (`TCPSocket::receiveAllDataWithLengthPrefix`), учитывая таймаут.
        4.  Получив ответ (также в формате "длина + данные"), обрабатывает его (выводит в консоль или файл).
    * **Сервер (в потоке из `ThreadPool` для данного клиента):**
        1.  Ожидает данные от клиента (`TCPSocket::receiveAllDataWithLengthPrefix`).
        2.  Получив запрос (длину, затем данные), передает строку запроса в `QueryParser`.
        3.  `QueryParser` разбирает строку и возвращает структурированный объект `Query`.
        4.  Объект `Query` передается в `ServerCommandHandler`.
        5.  `ServerCommandHandler` выполняет следующие действия в зависимости от `Query::type`:
            * Для операций чтения (`SELECT`, `PRINT_ALL`, `CALCULATE_CHARGES` (в части выборки записей)): Захватывает разделяемую блокировку (`std::shared_lock`) на `db_shared_mutex_`. Вызывает соответствующие методы `Database` для получения данных и `TariffPlan` (для `CALCULATE_CHARGES`).
            * Для операций записи (`ADD`, `DELETE`, `EDIT`, `LOAD`): Захватывает эксклюзивную блокировку (`std::unique_lock`) на `db_shared_mutex_`. Вызывает соответствующие методы `Database` для модификации данных.
            * Для `SAVE`: Также использует эксклюзивную блокировку для обеспечения консистентности при обновлении `currentFilename_` в `Database`.
            * Для `HELP`, `EXIT`: Формирует стандартный ответ.
        6.  `ServerCommandHandler` формирует текстовый ответ (результат операции или сообщение об ошибке), предваряя его статусом (`OK\n` или `ERROR\n` для упрощения парсинга на клиенте, хотя это не строгое требование протокола, а соглашение прикладного уровня).
        7.  Отправляет ответ клиенту, используя протокол "длина + данные" (`TCPSocket::sendAllDataWithLengthPrefix`).
3.  **Завершение сессии:**
    * **По команде `EXIT` от клиента:**
        * Клиент отправляет команду `EXIT`.
        * Сервер обрабатывает `EXIT`, отправляет подтверждающий ответ (`OK\nСервер подтверждает команду EXIT...`).
        * Клиент, получив ответ на `EXIT`, закрывает свое соединение.
        * Серверская задача `clientHandlerTask` завершает свой цикл после обработки `EXIT`.
    * **По локальной команде `QUIT_CLIENT` (клиент) или `EOF` (интерактивный режим) или завершение пакетного файла:**
        * Клиент отправляет специальное служебное сообщение `EXIT_CLIENT_SESSION` серверу (если соединение еще активно).
        * Клиент закрывает свое соединение.
        * Серверская задача `clientHandlerTask`, получив `EXIT_CLIENT_SESSION` или обнаружив разрыв соединения при следующей операции чтения, завершает свой цикл.
    * **При ошибках связи:** Если `send` или `recv` завершаются ошибкой (невозможно отправить данные, разрыв соединения, таймаут на стороне клиента), соответствующая сторона (клиент или серверная задача) завершает обработку и закрывает сокет.

### 2.3. Описание содержания теста, что делается, какой сценарий реализуется; описание того как запустить тест на выполнение и как убедиться, что тест прошел успешно

Тестирование Этапа 4 включает проверку корректности сетевого взаимодействия, обработки команд сервером и получения ответов клиентом. Основной упор делается на пакетный режим клиента для автоматизации и воспроизводимости.

#### 2.3.1. Цели тестирования Этапа 4
* Проверить корректность установления TCP-соединения между клиентом и сервером.
* Проверить правильность реализации протокола "длина сообщения + данные сообщения" для запросов и ответов.
* Проверить способность клиента и сервера обрабатывать сообщения различной длины, включая:
    * Короткие команды и ответы (например, `EXIT`, подтверждения).
    * Длинные команды (например, `ADD` с полным набором данных трафика).
    * Длинные ответы (например, результат `PRINT_ALL` для базы данных с несколькими сотнями или тысячами записей). Необходимо убедиться, что ответ не обрезается и приходит полностью (в рамках `MAX_MESSAGE_PAYLOAD_SIZE`).
* Проверить корректность обработки всех типов запросов, специфичных для задачи "Интернет-провайдер" (`ADD`, `SELECT`, `DELETE`, `EDIT`, `CALCULATE_CHARGES`, `PRINT_ALL`, `LOAD`, `SAVE`, `EXIT`), через сетевое взаимодействие.
* Проверить работу сервера при одновременном подключении нескольких клиентов (может быть выполнено путем ручного запуска нескольких экземпляров клиента или через специализированные скрипты для нагрузочного тестирования, что выходит за рамки базового теста Этапа 4, но является направлением для развития).
* Проверить корректность работы пакетного режима клиента (чтение команд из файла, игнорирование комментариев и пустых строк, запись результатов в выходной файл).
* Проверить обработку ошибок (например, сервер недоступен, неверный синтаксис запроса, ошибки файловых операций `LOAD`/`SAVE` на сервере, доступ к несуществующим записям).

#### 2.3.2. Сценарий основного теста (пакетный режим)
Данный сценарий описан в `README.md` в разделе "2.5. Тестирование реализации Этапа 4" -> "Пакетный режим проверки". Он включает:
1.  **Подготовку:**
    * Создание тестового файла данных для базы (например, `data/provider_data_test.txt` с помощью `generate_data`).
    * Наличие файла тарифного плана (например, `data/tariff_default.cfg`).
    * Создание файла с последовательностью тестовых запросов (например, `data/stage4_test_queries.txt`). Этот файл должен содержать разнообразные команды, включая:
        * `LOAD "provider_data_test.txt" END` (для заполнения базы)
        * `PRINT_ALL END` (для проверки получения потенциально большого ответа)
        * `ADD FIO "Тест Абонент Тестович" IP "192.168.1.100" DATE "01.01.2024" TRAFFIC_IN 0 0 ... 1 TRAFFIC_OUT 0 ... 0.5 END`
        * `SELECT FIO "Тест Абонент Тестович" END`
        * `CALCULATE_CHARGES FIO "Тест Абонент Тестович" START_DATE "01.01.2024" END_DATE "31.01.2024" END`
        * `EDIT FIO "Тест Абонент Тестович" SET IP "192.168.1.101" END`
        * `SELECT IP "192.168.1.101" END`
        * `DELETE FIO "Тест Абонент Тестович" END`
        * `SELECT FIO "Тест Абонент Тестович" END` (ожидается "не найдено")
        * Запросы с некорректным синтаксисом для проверки обработки ошибок сервером.
        * `SAVE "provider_data_after_test.txt" END`
        * `EXIT`
    * (Опционально) Подготовка эталонных файлов с ожидаемыми ответами для автоматического сравнения.

2.  **Запуск теста:**
    * Запустить сервер `database_server` с указанием порта, файла тарифов и директории данных (например, `./bin/database_server -p 12345 -t ../../data/tariff_default.cfg -d ../../`). Сервер должен иметь доступ к файлу `provider_data_test.txt` для команды `LOAD` (путь в `LOAD` должен быть относительным к `server_data_root_dir/DEFAULT_SERVER_DATA_SUBDIR` или абсолютным, доступным серверу).
    * Запустить клиент `database_client` в пакетном режиме:
        `./bin/database_client -s localhost -p 12345 -f ../../data/stage4_test_queries.txt -o stage4_test_results.txt`

3.  **Проверка результатов и успешности теста:**
    * **Автоматическая проверка (если реализовано в скрипте):** Сравнить сгенерированный файл `stage4_test_results.txt` с эталонным файлом ответов с помощью утилиты `diff`. Отсутствие различий указывает на успех этой части теста.
    * **Ручная проверка (если нет авто-сравнения или для дополнительного контроля):**
        * Открыть `stage4_test_results.txt` и проверить, что:
            * Все команды из файла запросов были обработаны.
            * Ответы сервера корректны и полны (особенно для `PRINT_ALL`).
            * Сообщения об ошибках (если были некорректные запросы) информативны.
            * Команда `EXIT` была подтверждена сервером.
        * Проверить логи сервера (`server.log`) и клиента (`client.log`) на отсутствие сообщений об ошибках уровня `ERROR` или критических предупреждений (`WARN`), не связанных с ожидаемой обработкой некорректных запросов.
        * Проверить, что файл `provider_data_after_test.txt` был создан на сервере (в директории `server_data_root_dir/server_databases/`) и содержит ожидаемые данные после выполнения всех команд (например, добавленные записи присутствуют, удаленные – отсутствуют).
    * **Тест считается успешным, если:**
        * Все команды из файла запросов были отправлены и для каждой получен ответ.
        * Содержание файла ответов соответствует ожидаемому (в идеале, совпадает с эталонным файлом).
        * В логах нет непредвиденных ошибок.
        * Состояние базы данных на сервере (после `SAVE`) соответствует выполненным операциям.

#### 2.3.3. Дополнительные тесты (ручные или скриптовые)
* **Проверка интерактивного режима:** Запустить клиент в интерактивном режиме и выполнить ряд команд вручную, проверяя ответы.
* **Проверка обработки ошибок подключения:** Попытаться запустить клиент, когда сервер не запущен, или указать неверный адрес/порт.
* **Проверка таймаутов:** (Сложно автоматизировать без специальной настройки сервера) Установить короткий таймаут на клиенте и выполнить команду, которая требует длительной обработки на сервере (или искусственно замедлить ответ сервера), чтобы проверить корректность срабатывания таймаута на клиенте.

## 3. Реализованная функциональность на Этапе 4 (Сводка)
... (существующий раздел из вашего README, можно немного сократить, т.к. детали уже выше) ...

## 4. Ключевые улучшения в данной версии (по сравнению с начальной реализацией Этапа 4)
... (существующий раздел) ...

## 5. Дальнейшее развитие и возможные улучшения
... (существующий раздел, плюс дополнение про многочастные ответы) ...

## 6. Структура Проекта
... (существующий раздел) ...

## 7. Инструкции по сборке и запуску
... (существующий раздел) ...




# База Данных Интернет-Провайдера - Этап 4: Клиент-Серверная Архитектура (Улучшенная Версия)

## 1. Введение

Данный документ описывает реализацию Этапа 4 проекта "База Данных Интернет-Провайдера", доработанную с учетом требований к надежности, производительности и удобству использования. Целью этого этапа являлось преобразование ранее созданного консольного приложения для работы с базой данных в полноценную клиент-серверную систему. Это включает разделение логики на серверную часть (обработка запросов, управление БД) и клиентскую часть (отправка запросов, получение результатов), а также организацию их сетевого взаимодействия по протоколу TCP/IP.

Проект выполнен в соответствии с заданием №9 "Интернет провайдер" для 4-го семестра.

## 2. Реализованная функциональность на Этапе 4 (Улучшенная Версия)

### 2.1. Архитектура Клиент-Сервер

Система разделена на два основных компонента: серверное приложение (`database_server`) и клиентское приложение (`database_client`).

* **Сервер (`database_server`):**
    * Отвечает за хранение и управление базой данных абонентов (`Database`) и тарифным планом (`TariffPlan`).
    * Использует `QueryParser` для разбора текстовых запросов, полученных от клиентов.
    * Запускается как отдельное приложение, прослушивающее указанный TCP-порт для входящих клиентских соединений.
    * Для обработки клиентских запросов используется **пул потоков (`ThreadPool`)**, размер которого настраивается (по умолчанию 4 потока). Это обеспечивает эффективное управление ресурсами и позволяет обрабатывать несколько клиентских запросов одновременно.
    * Доступ к объекту `Database` синхронизирован с помощью **`std::shared_mutex`**. Операции чтения (например, `SELECT`, `PRINT_ALL`) используют разделяемую блокировку (`std::shared_lock`), позволяя одновременный доступ нескольким клиентам. Операции записи (например, `ADD`, `DELETE`, `EDIT`, `LOAD`, `SAVE`) используют эксклюзивную блокировку (`std::unique_lock`), гарантируя целостность данных.
    * Обрабатывает следующие команды от клиентов:
        * `ADD`: Добавление новой записи абонента.
        * `SELECT`: Выборка записей по различным критериям (ФИО, IP, дата).
        * `DELETE`: Удаление записей по критериям.
        * `EDIT`: Редактирование существующей записи по критериям.
        * `CALCULATE_CHARGES`: Расчет начислений для выбранных абонентов за указанный период на основе тарифного плана.
        * `PRINT_ALL`: Вывод всех записей из базы данных.
        * `LOAD`: Загрузка данных из файла на сервере в базу данных.
        * `SAVE`: Сохранение текущего состояния базы данных в файл на сервере.
        * `EXIT`: Подтверждение завершения сессии клиента.
        * `HELP`: Предоставление базовой информации о поддерживаемых командах.
    * Операции `LOAD` и `SAVE` выполняются с файловой системой сервера. Для обеспечения безопасности используется функция `getSafeServerFilePath_SCH`, которая формирует пути к файлам в пределах специально отведенной и контролируемой директории (по умолчанию `server_databases` относительно базового пути данных сервера), предотвращая несанкционированный доступ.
    * Параметры сервера (порт, путь к файлу тарифов, базовая директория для данных, уровень и файл логирования, размер пула потоков) могут быть заданы через **конфигурационный файл** (например, `server.conf`) и/или переопределены аргументами командной строки.
    * Реализовано корректное завершение работы сервера при получении сигналов `SIGINT` / `SIGTERM` (для POSIX-систем) или консольных управляющих событий `CTRL_C_EVENT`, `CTRL_CLOSE_EVENT` и др. (для Windows). Завершение включает закрытие слушающего сокета, остановку пула потоков и корректное завершение активных задач и потока-акцептора.
    * Ведет подробное логирование своей работы с использованием класса `Logger` с настраиваемым уровнем детализации (DEBUG, INFO, WARN, ERROR, NONE) и возможностью вывода как в консоль, так и в указанный файл.

* **Клиент (`database_client`):**
    * Запускается как отдельное консольное приложение.
    * Принимает адрес сервера, порт и другие опции (включая файл команд для пакетного режима, файл для вывода результатов, таймаут ожидания ответа от сервера, настройки логирования) через параметры командной строки.
    * Может работать в двух режимах:
        * **Интерактивный режим:** Пользователь вводит команды непосредственно в консоль клиента. Команды отправляются на сервер для выполнения, а ответы сервера выводятся в консоль. Поддерживаются локальные команды `HELP` (для вывода справки по командам) и `QUIT_CLIENT` (для немедленного выхода из программы с уведомлением сервера).
        * **Пакетный режим (`-f <файл_запросов>`):** Клиент считывает команды из указанного текстового файла (игнорируя пустые строки и строки, начинающиеся с `#` как комментарии), последовательно отправляет их на сервер и сохраняет ответы сервера в выходной файл. Имя выходного файла формируется автоматически на основе имени файла запросов (например, `input.txt` -> `input.out.txt`) или может быть явно указано через опцию `-o`.
    * Отправляет команды на сервер и получает текстовые ответы, корректно обрабатывая их.
    * Реализована отправка специальной команды `EXIT_CLIENT_SESSION` серверу для уведомления о корректном завершении сессии со стороны клиента (например, при выходе из клиента, по команде `EXIT` из файла/интерактивного режима, или при обработке `EOF`).
    * Ведет логирование своей работы с использованием класса `Logger` с настраиваемым уровнем и файлом вывода.

* **Сетевое взаимодействие и протокол обмена данными:**
    * **Протокол передачи**: Взаимодействие осуществляется по протоколу TCP/IP, обеспечивающему надежную доставку сообщений.
    * **Формат сообщений**: Для обмена сообщениями между клиентом и сервером реализован протокол "длина сообщения + данные сообщения".
        * **Префикс длины**: Каждому текстовому сообщению (запросу от клиента или ответу от сервера) предшествует 4-байтовый префикс, представляющий длину последующих данных в байтах. Это значение передается в сетевом порядке байт (big-endian), для чего используются функции `htonl` при отправке и `ntohl` при получении.
        * **Данные сообщения**: Сами данные представляют собой текстовую строку в кодировке UTF-8.
        * **Максимальный размер**: Максимальный размер полезной нагрузки одного сообщения (без учета 4-байтового префикса длины) ограничен константой `MAX_MESSAGE_PAYLOAD_SIZE` (20 МБ) для предотвращения чрезмерного использования ресурсов и потенциальных атак.
    * **Реализация**: Класс `TCPSocket` инкапсулирует работу с сокетами и протоколом. Методы `sendAllDataWithLengthPrefix` и `receiveAllDataWithLengthPrefix` отвечают за корректную отправку и прием сообщений с учетом префикса длины. Это решает проблему передачи и приема сообщений переменной длины и согласования размеров буферов между клиентом и сервером для каждого отдельного сообщения.
    * **Проверка каналов обмена**: Надежность на транспортном уровне обеспечивается TCP. На прикладном уровне, протокол "длина + данные" позволяет корректно выделять сообщения из потока байт. Таймауты на операции получения в `TCPSocket` помогают обрабатывать ситуации отсутствия ответа от другой стороны.
    * **Служебные сообщения**: Клиент может отправить специальную строку `"EXIT_CLIENT_SESSION"` (также с префиксом длины), чтобы уведомить сервер о штатном завершении сеанса со своей стороны, позволяя серверу освободить связанные ресурсы. Команда `EXIT`, отправленная пользователем (в интерактивном или пакетном режиме), также обрабатывается как запрос на завершение сессии: сервер подтверждает ее, и клиент после получения подтверждения закрывает соединение.

### 2.2. Обработка команд на сервере

* Класс `ServerCommandHandler` инкапсулирует всю логику обработки команд, полученных от клиента. Он создается для каждой клиентской сессии (задачи в пуле потоков).
* Логика выполнения команд (`ADD`, `SELECT`, `DELETE`, `EDIT`, `CALCULATE_CHARGES`, `PRINT_ALL`, `LOAD`, `SAVE`) полностью находится внутри `ServerCommandHandler` и его вспомогательных методов.
* Операции `LOAD` и `SAVE` используют функцию `getSafeServerFilePath_SCH` для валидации имени файла от клиента и формирования безопасного абсолютного пути к файлу на сервере. Это гарантирует, что файловые операции производятся только в пределах специально отведенной поддиректории (`DEFAULT_SERVER_DATA_SUBDIR`) относительно базового пути данных сервера, предотвращая несанкционированный доступ к другим частям файловой системы.
* Результаты выполнения команд и сообщения об ошибках аккуратно формируются в виде строки и возвращаются для отправки клиенту. Класс `Database` теперь возвращает структурированный результат `FileOperationResult` для операций `loadFromFile` и `saveToFile`, что позволяет `ServerCommandHandler` формировать более информативные ответы.
* Обеспечена детальная обработка стандартных исключений (`std::invalid_argument`, `std::out_of_range`, `std::runtime_error`, `std::exception`) на уровне `ServerCommandHandler::processCommand`, а также отлов неизвестных исключений.

### 2.3. Логирование

* Реализован и повсеместно интегрирован статический класс `Logger` (`logger.h`, `logger.cpp`).
* Поддерживаются уровни логирования: `DEBUG`, `INFO`, `WARN`, `ERROR`, `NONE`.
* Вывод логов осуществляется в консоль (ошибки и предупреждения в `std::cerr`, остальное в `std::cout`) и дублируется в файл, если путь к файлу указан при инициализации `Logger`.
* Формат лог-сообщения включает: временную метку с миллисекундами, уровень лога, идентификатор потока, опциональное имя модуля/компонента и само сообщение.
* Доступ к общим ресурсам логгера (например, файловому потоку) синхронизирован с помощью `std::mutex`, что делает его безопасным для использования в многопоточной среде сервера.
* Логирование добавлено во все ключевые компоненты системы.

### 2.4. Конфигурация Сервера

* Добавлен компонент `ServerConfig` (`server_config.h`, `server_config.cpp`) для управления конфигурацией сервера.
* Сервер при запуске пытается загрузить параметры из файла `server.conf` (имя и расположение могут быть настроены). Файл конфигурации использует простой формат "ключ=значение".
* Аргументы командной строки имеют приоритет над значениями из конфигурационного файла, а те, в свою очередь, над значениями по умолчанию, жестко заданными в коде.
* Конфигурируемые параметры включают: порт сервера, размер пула потоков, путь к файлу тарифов, базовую директорию для файлов данных сервера, уровень логирования и путь к файлу лога сервера.

### 2.5. Тестирование реализации Этапа 4

Для проверки корректности реализации клиент-серверного взаимодействия на Этапе 4 предусмотрены следующие подходы:

* **Ручной режим проверки**:
    1.  Запустите сервер `database_server`, указав необходимые параметры (порт, файл тарифов и т.д.). Убедитесь, что сервер успешно стартовал и ожидает соединений (сообщения в логе сервера).
    2.  Запустите клиент `database_client` в интерактивном режиме, указав адрес и порт запущенного сервера.
        ```bash
        ./bin/database_client -s localhost -p 12345
        ```
    3.  После успешного подключения, вводите различные команды (например, `PRINT_ALL END`, `ADD FIO "Тест Тестович" IP "1.2.3.4" DATE "01.01.2024" END`, `SELECT FIO "Тест Тестович" END`, `EXIT`) и проверяйте корректность ответов сервера, выводимых в консоль клиента.
    4.  Проверьте логи сервера и клиента на наличие ошибок или неожиданного поведения.

* **Пакетный режим проверки (основной для автоматизации тестов Этапа 4)**:
    * **Сценарий теста**: Клиент считывает последовательность команд из файла, отправляет их на сервер, получает ответы и сохраняет их в другой файл. Это позволяет проверить обработку различных команд и корректность приема ответов, включая ответы разного объема.
    * **Подготовка**:
        1.  Подготовьте файл с тестовыми данными для базы (например, `data/provider_data_test.txt`). Его можно сгенерировать утилитой `generate_data` или создать вручную.
        2.  Подготовьте файл с тарифным планом (например, `data/tariff_default.cfg`).
        3.  Подготовьте файл с последовательностью запросов (например, `data/stage4_test_queries.txt`). Этот файл должен включать команды, генерирующие как короткие, так и потенциально длинные ответы:
            ```
            # Файл: data/stage4_test_queries.txt
            LOAD "provider_data_test.txt" END
            PRINT_ALL END
            ADD FIO "Новый Абонент 1" IP "10.0.0.1" DATE "15.05.2024" TRAFFIC_IN 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 TRAFFIC_OUT 0.5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.5 END
            SELECT FIO "Новый Абонент 1" END
            CALCULATE_CHARGES FIO "Новый Абонент 1" START_DATE "01.05.2024" END_DATE "31.05.2024" END
            EDIT FIO "Новый Абонент 1" SET IP "10.0.0.2" END
            SELECT IP "10.0.0.2" END
            DELETE FIO "Новый Абонент 1" IP "10.0.0.2" END
            SELECT FIO "Новый Абонент 1" END # Должен вернуть "не найдено"
            SAVE "provider_data_test_after_stage4.txt" END
            EXIT
            ```
        4.  (Опционально) Подготовьте эталонный файл с ожидаемыми ответами.
    * **Запуск теста**:
        1.  Запустите сервер:
            ```bash
            ./bin/database_server -p 12345 -t ../../data/tariff_default.cfg -d ../../ # Укажите корректные пути
            ```
            (Убедитесь, что сервер имеет доступ к `provider_data_test.txt` через указанную data-dir, если `LOAD` использует относительный путь к файлу на сервере, или используйте абсолютные пути в команде `LOAD`).
        2.  Запустите клиент в пакетном режиме:
            ```bash
            ./bin/database_client -s localhost -p 12345 -f ../../data/stage4_test_queries.txt -o stage4_test_results.txt
            ```
    * **Проверка результатов**:
        1.  Проверьте файл `stage4_test_results.txt`. Убедитесь, что все команды выполнены и ответы сервера корректны и полны. Обратите особое внимание на вывод команды `PRINT_ALL` (если база была не пуста) – он должен быть получен полностью, демонстрируя обработку ответа большого объема.
        2.  Проверьте логи сервера и клиента на отсутствие ошибок.
        3.  Проверьте, что файл `provider_data_test_after_stage4.txt` был создан на сервере (в соответствующей директории, например `server_data_root/server_databases/`) и содержит ожидаемые данные.
        4.  Если есть эталонный файл ответов, сравните `stage4_test_results.txt` с ним.

* **Альтернативные подходы к распределению обработки клиентов (теоретическое рассмотрение)**:
    Текущая реализация использует пул потоков, где каждый запрос от клиента может быть обработан одним из потоков пула. Это обеспечивает хороший баланс между использованием ресурсов и параллелизмом. Альтернативные подходы включают:
    * **Поток на соединение**: Создание нового потока для каждого клиентского соединения. Просто в реализации, но может быть неэффективно при большом количестве клиентов из-за накладных расходов на создание потоков и переключение контекста.
    * **Процесс на соединение**: Аналогично потоку на соединение, но с использованием процессов. Еще большие накладные расходы.
    * **Асинхронная однопоточная/малопоточная обработка**: Использование неблокирующего ввода-вывода с мультиплексированием событий (например, `select`, `poll`, `epoll` в Linux, `kqueue` в BSD/macOS, `IOCP` в Windows) или библиотек типа Boost.Asio. Этот подход наиболее масштабируем для очень большого числа одновременных соединений, так как избегает большого количества потоков. Данный подход рассматривается как возможное направление для дальнейшего развития проекта.

### 2.6. Структура Проекта и Сборка

* Проект имеет модульную структуру с разделением на директории `src/core`, `src/utils`, `src/net`, `src/server`, `src/client`.
* Используется система сборки `CMake` (`CMakeLists.txt`).
* Проект собирается с использованием стандарта C++17.
* `CMakeLists.txt` настроен для сборки статических библиотек `core_utils_lib` и `net_lib`, а также исполняемых файлов сервера, клиента, генератора данных и модульных тестов.
* Настроена генерация API документации с помощью Doxygen и анализ покрытия кода с помощью LCOV (для Debug-сборок).

## 3. Ключевые улучшения в данной версии (по сравнению с начальной реализацией Этапа 4)

* **Пул потоков (`ThreadPool`):** Сервер теперь использует пул потоков для обработки клиентских запросов.
* **Гранулярные блокировки базы данных (`std::shared_mutex`):** Доступ к `Database` со стороны сервера синхронизирован.
* **Конфигурация сервера через файл (`ServerConfig`):** Добавлена возможность настройки параметров сервера через конфигурационный файл.
* **Улучшенная обработка файловых операций в `Database`:** Методы `loadFromFile` и `saveToFile` возвращают `FileOperationResult`.
* **Улучшенное логирование:** Логирование стало более последовательным и подробным.
* **Более надежное закрытие сокетов и завершение работы.**
* **Улучшения в клиенте:** Настройка таймаута ожидания ответа и пути к файлу лога.


## 4. Дальнейшее развитие и возможные улучшения

Хотя текущая реализация соответствует основным требованиям Этапа 4, существует ряд направлений для дальнейшего усовершенствования:

1.  **Надежность и Производительность Сервера (Продвинутый уровень):**
    * **Асинхронная сетевая модель:** Рассмотреть переход на неблокирующий ввод-вывод с использованием `epoll` (Linux), `kqueue` (BSD/macOS), `IOCP` (Windows) или библиотек типа Boost.Asio для максимальной масштабируемости при очень большом количестве одновременных соединений.
    * **Таймауты на стороне сервера:** Реализовать общие таймауты на неактивность клиентской сессии.
    * **Ограничение ресурсов:** Внедрить механизмы для предотвращения злоупотреблений (например, ограничение количества запросов от одного IP, максимальный размер принимаемых запросов).

2.  **Протокол и Данные:**
    * **Версионирование протокола:** Для будущих расширений протокола обмена.
    * **Структурированный формат данных:** Вместо передачи текстовых строк, рассмотреть использование JSON, Protocol Buffers или MessagePack, особенно если планируется взаимодействие с клиентами на других языках или передача сложных структур данных.
    * **Сжатие данных:** Для уменьшения сетевого трафика при передаче больших объемов информации (например, результатов `PRINT_ALL` для больших баз).

3.  **Безопасность:**
    * **SSL/TLS шифрование:** Обязательно для защиты данных, передаваемых по сети, в производственной среде или при работе в недоверенных сетях.
    * **Аутентификация и Авторизация клиентов:** Если потребуется разграничение прав доступа к базе данных.

4.  **Клиентская часть:**
    * **Улучшенный интерактивный режим:** Добавление истории команд, автодополнения, редактирования ввода (например, с использованием библиотеки GNU Readline или аналогов).
    * **Графический интерфейс пользователя (GUI):** Для более удобного взаимодействия с базой данных.

5.  **Тестирование:**
    * **Расширение Unit-тестов:** Написать тесты для новых компонентов (`ThreadPool`, `ServerConfig`) и обеспечить максимальное покрытие кода тестами для всех существующих модулей, включая обработку граничных случаев и ошибок.
    * **Развитие Интеграционных тестов:**
        * Сценарии с большим количеством одновременных клиентов (нагрузочное тестирование).
        * Тесты, проверяющие корректность работы `std::shared_mutex` при различных сценариях чтения/записи.
        * Сценарии с имитацией различных сетевых проблем (разрыв соединения, задержки, потеря пакетов - если протокол UDP, но здесь TCP).
        * Тесты длительной работы сервера (soak tests) для выявления утечек ресурсов или деградации производительности.
    * **Тесты производительности (бенчмарки):** Для измерения пропускной способности сервера (запросов в секунду) и времени отклика на различные типы запросов.

6.  **Качество кода и сборка:**
    * **Статический анализ кода:** Регулярное использование инструментов типа Clang-Tidy, Cppcheck для выявления потенциальных проблем и улучшения стиля кода.
    * **Динамический анализ кода:** Использование Valgrind (на Linux) для обнаружения утечек памяти и ошибок работы с памятью; AddressSanitizer (ASan), ThreadSanitizer (TSan) при компиляции для выявления ошибок памяти и гонок данных.

## 5. Структура Проекта

```plaintext
📁 InternetProviderDB_CS/
├── 📄 CMakeLists.txt                # Главный файл сборки CMake
├── 📄 README.md                     # Этот файл описания проекта
├── 📄 Doxyfile.in                  # Шаблон конфигурационного файла Doxygen (или Doxyfile)
├── 📄 server.conf.example           # Пример конфигурационного файла для сервера
├── 📁 data/                         # Директория с примерами данных для разработки/тестирования
│   ├── 📄 provider_data_default.txt # Пример файла с данными для БД
│   ├── 📄 queries_client_example.txt# Пример файла с запросами для пакетного режима клиента
│   └── 📄 tariff_default.cfg        # Пример файла конфигурации тарифного плана
├── 📁 server_data_root/            # (Может создаваться сервером) Рабочая директория сервера 
│   └── 📁 server_databases/        #   Поддиректория по умолчанию для файлов БД (LOAD/SAVE)
├── 📁 src/                          # Корневая директория исходного кода
│   ├── 📄 common_defs.h             # Общие определения и константы
│   ├── 📁 core/                     # Ядро логики базы данных
│   │   ├── 📄 database.cpp
│   │   ├── 📄 database.h
│   │   ├── 📄 date.cpp
│   │   ├── 📄 date.h
│   │   ├── 📄 ip_address.cpp
│   │   ├── 📄 ip_address.h
│   │   ├── 📄 provider_record.cpp
│   │   ├── 📄 provider_record.h
│   │   ├── 📄 query_parser.cpp
│   │   ├── 📄 query_parser.h
│   │   ├── 📄 tariff_plan.cpp
│   │   └── 📄 tariff_plan.h
│   ├── 📁 net/                      # Сетевые компоненты
│   │   ├── 📄 tcp_socket.cpp
│   │   └── 📄 tcp_socket.h
│   ├── 📁 server/                   # Компоненты серверной части
│   │   ├── 📄 server_main.cpp         # Точка входа сервера
│   │   ├── 📄 server.cpp
│   │   ├── 📄 server.h
│   │   ├── 📄 server_command_handler.cpp
│   │   ├── 📄 server_command_handler.h
│   │   ├── 📄 server_config.cpp     # Новый: Логика конфигурации сервера
│   │   └── 📄 server_config.h       # Новый: Структура конфигурации сервера
│   ├── 📁 client/                   # Компоненты клиентской части
│   │   └── 📄 client_main.cpp         # Точка входа клиента
│   └── 📁 utils/                    # Вспомогательные утилиты
│       ├── 📄 file_utils.cpp
│       ├── 📄 file_utils.h
│       ├── 📄 logger.cpp
│       ├── 📄 logger.h
│       ├── 📄 thread_pool.cpp     # Новый: Реализация пула потоков
│       └── 📄 thread_pool.h       # Новый: Заголовок пула потоков
├── 📁 tools/                        # Дополнительные инструменты (например, генератор данных)
│   └── 📄 generator.cpp             # Генератор тестовых данных
├── 📁 unit_tests/                   # Директория с модульными тестами
│   ├── 📄 test_main.cpp             # Главный файл для запуска тестов GTest
│   ├── 📄 test_date.cpp
│   ├── 📄 test_ip_address.cpp
│   ├── 📄 test_provider_record.cpp
│   ├── 📄 test_tariff_plan.cpp
│   ├── 📄 test_query_parser.cpp
│   ├── 📄 test_database.cpp
│   ├── 📄 test_file_utils.cpp
│   ├── 📄 test_logger.cpp          
│   ├── 📄 test_tcp_socket.cpp      
│   ├── 📄 test_server_command_handler.cpp 
│   ├── (📄 test_thread_pool.cpp)    # (Рекомендуется добавить)
│   └── (📄 test_server_config.cpp)  # (Рекомендуется добавить)
└── 📁 integration_tests/            # Директория с интеграционными тестами
    ├── 📄 run_all_tests.sh          # Скрипт для запуска всех интеграционных тестов (для UNIX)
    ├── 📄 test_common.sh            # Общие функции для скриптов интеграционных тестов
    └── 📁 scenarios/                # Сценарии для интеграционных тестов
        └── ... (файлы сценариев, начальные данные, ожидаемые результаты)
```

## 6. Инструкции по сборке и запуску

Этот раздел описывает, как собрать проект из исходного кода и как запустить серверное и клиентское приложения.

### 6.1. Требования к сборке

Для успешной сборки и запуска проекта вам понадобятся следующие инструменты и компоненты:

* **Компилятор C++:** С поддержкой стандарта C++17.
    * **Linux/macOS:** GCC (версия 7 или новее) или Clang (версия 5 или новее).
    * **Windows:** Microsoft Visual C++ (MSVC) 2017 или новее (входит в состав Visual Studio).
* **Система сборки CMake:** Версия 3.14 или выше. CMake используется для генерации файлов сборки для вашей целевой платформы и компилятора.
* **Doxygen (опционально):** Для генерации API документации из комментариев в исходном коде.
    * **Graphviz (опционально, для Doxygen):** Если вы хотите, чтобы Doxygen генерировал диаграммы (например, графы вызовов, диаграммы наследования), вам также потребуется установить Graphviz.
* **Инструменты для анализа покрытия кода (опционально, для Linux/macOS с GCC/Clang):**
    * **LCOV:** Инструмент для сбора данных о покрытии кода, сгенерированных GCC/Clang.
    * **genhtml:** Часть LCOV, используется для генерации HTML-отчетов о покрытии.
    * **gcov (для GCC) / llvm-cov (для Clang):** Инструменты, поставляемые с компиляторами, для фактического профилирования кода.
* **Bash (для UNIX-подобных систем):** Используется для запуска скриптов интеграционных тестов. На Windows для запуска shell-скриптов может потребоваться WSL (Windows Subsystem for Linux), Cygwin или адаптация скриптов под PowerShell/CMD.

### 6.2. Сборка проекта

Процесс сборки проекта стандартен для проектов, использующих CMake:

1.  **Клонируйте репозиторий или распакуйте архив с исходным кодом** в выбранную вами директорию (далее – `<корневая_директория_проекта>`).
2.  **Создайте отдельную директорию для сборки.** Это рекомендуемая практика, чтобы не загрязнять директорию с исходным кодом файлами сборки.
    ```bash
    cd <корневая_директория_проекта>
    mkdir build
    cd build
    ```
3.  **Сконфигурируйте проект с помощью CMake.** На этом этапе CMake проанализирует `CMakeLists.txt`, найдет ваш компилятор и сгенерирует файлы сборки (например, Makefiles для Linux/macOS, проект Visual Studio для Windows).
    ```bash
    # Базовая конфигурация (обычно CMake выбирает подходящий генератор)
    cmake .. 
    ```
    Вы можете указать дополнительные опции CMake при конфигурации:
    * **Тип сборки (`CMAKE_BUILD_TYPE`):**
        * `Debug`: Сборка с отладочной информацией, без оптимизаций (или с минимальными). Полезна для разработки и отладки.
            ```bash
            cmake .. -DCMAKE_BUILD_TYPE=Debug
            ```
        * `Release`: Сборка с оптимизациями для производительности, без отладочной информации (или с ограниченной). Рекомендуется для финальных версий.
            ```bash
            cmake .. -DCMAKE_BUILD_TYPE=Release
            ```
        * Другие типы (например, `RelWithDebInfo`, `MinSizeRel`) также могут быть доступны в зависимости от вашего генератора CMake. Если тип сборки не указан, CMake может выбрать значение по умолчанию (часто это `None` или `Debug`).
    * **Включение анализа покрытия кода (`ENABLE_COVERAGE`):** Эта опция доступна только для Debug-сборок с компиляторами GCC или Clang.
        ```bash
        cmake .. -DCMAKE_BUILD_TYPE=Debug -DENABLE_COVERAGE=ON
        ```
    * **Выбор генератора (если нужно):** Например, для генерации файлов Ninja вместо Makefiles:
        ```bash
        cmake .. -G "Ninja"
        ```
4.  **Соберите проект.** После успешной конфигурации выполните команду сборки:
    ```bash
    cmake --build .
    ```
    Или, если вы используете Makefiles (по умолчанию на Linux/macOS):
    ```bash
    make
    # Для параллельной сборки (используя количество доступных процессоров):
    # make -j$(nproc)  # Для Linux
    # make -j<N>       # Где <N> - количество потоков сборки
    ```
    Если вы используете Ninja:
    ```bash
    ninja
    ```
    Если вы используете Visual Studio, откройте сгенерированный `.sln` файл и соберите проект из IDE.

5.  **Результаты сборки:**
    * **Исполняемые файлы:** `database_server`, `database_client`, `generate_data`, `run_unit_tests` будут находиться в директории `<корневая_директория_проекта>/build/bin/`.
    * **Статические библиотеки:** `core_utils_lib` (libcore_utils_lib.a или core_utils_lib.lib) и `net_lib` (libnet_lib.a или net_lib.lib) будут находиться в директории `<корневая_директория_проекта>/build/lib/`.
 
### 6.3. Запуск Сервера

Серверное приложение `database_server` необходимо запустить перед тем, как клиенты смогут к нему подключаться.

1.  Перейдите в директорию, где находятся исполняемые файлы (обычно `<корневая_директория_проекта>/build/bin/`).
2.  Запустите сервер из командной строки:
    ```bash
    ./database_server [опции]
    ```

**Основные опции командной строки для сервера:**

* `-c, --config <файл>`: Путь к файлу конфигурации сервера (например, `../../server.conf.example`, если запускать из `build/bin/`). Опции из командной строки имеют приоритет над этим файлом.
* `-p, --port <порт>`: Номер сетевого порта, на котором сервер будет ожидать входящие соединения (например, `12345`). Переопределяет значение из файла конфигурации.
* `--threads <N>`: Количество рабочих потоков в пуле для обработки клиентских запросов (например, `4` или `8`). Переопределяет значение из файла конфигурации.
* `-t, --tariff <файл>`: Путь к файлу тарифного плана (например, `../../data/tariff_default.cfg`). Переопределяет значение из файла конфигурации.
* `-d, --data-dir <директория>`: Корневая директория на сервере, где будут храниться файлы баз данных (для операций `LOAD` и `SAVE`). Файлы будут помещаться в поддиректорию `server_databases` внутри указанной директории. Если не указан, используется автоопределение (например, директория исполняемого файла или корень проекта). Переопределяет значение из файла конфигурации.
* `-l, --log-level <LEVEL>`: Уровень детализации логирования для сервера. Доступные уровни: `DEBUG`, `INFO`, `WARN`, `ERROR`, `NONE`. Переопределяет значение из файла конфигурации.
* `--log-file <файл>`: Путь к файлу, в который будут записываться логи сервера (например, `server_app.log`). Если указан пустой путь или опция отсутствует, и в конфигурационном файле не указан путь, логирование будет осуществляться в файл по умолчанию (`server.log`) или только в консоль (в зависимости от реализации `Logger::init`). Переопределяет значение из файла конфигурации.
* `-h, --help`: Показать справочную информацию по всем доступным опциям и выйти.

**Пример запуска сервера с использованием файла конфигурации (рекомендуется):**
(Предполагается, что `server.conf.example` был скопирован в `server.conf` и настроен, и вы находитесь в директории `build`)
```bash
./bin/database_server -c ../server.conf.example
```

После успешного запуска сервер выведет в лог (и, возможно, в консоль) сообщение о том, что он запущен и ожидает соединений. Для остановки сервера используйте `Ctrl+C` в консоли, где он запущен, или отправьте ему сигнал `SIGTERM` (на POSIX-системах).

### 6.4. Запуск Клиента

Клиентское приложение `database_client` используется для подключения к запущенному серверу и отправки ему запросов.

1.  Убедитесь, что сервер `database_server` запущен и доступен.
2.  Перейдите в директорию, где находятся исполняемые файлы (обычно `<корневая_директория_проекта>/build/bin/`).
3.  Запустите клиент из командной строки:
    ```bash
    ./database_client -s <адрес_сервера> [опции]
    ```

**Обязательная опция клиента:**

* `-s, --server <адрес>`: Адрес (IP-адрес или DNS-имя) хоста, на котором запущен сервер (например, `localhost`, `127.0.0.1`, или IP-адрес удаленного сервера).

**Основные опциональные опции клиента:**

* `-p, --port <порт>`: Сетевой порт, на котором сервер ожидает соединения (по умолчанию: `12345`). Должен совпадать с портом, на котором запущен сервер.
* `-f, --file <файл_запросов>`: Активирует пакетный режим работы. Клиент будет считывать команды из указанного `<файла_запросов>` и отправлять их на сервер.
* `-o, --output <файл_вывода>`: (Используется только в пакетном режиме `-f`) Указывает файл, в который будут сохранены ответы сервера. Если не указан, имя выходного файла формируется автоматически на основе имени файла запросов (например, `<имя_файла_запросов>.out.txt`).
* `--timeout <мс>`: Таймаут ожидания ответа от сервера в миллисекундах (по умолчанию: `120000` мс, т.е. 2 минуты).
* `-l, --log-level <LEVEL>`: Уровень детализации логирования для клиента (`DEBUG`, `INFO`, `WARN`, `ERROR`, `NONE`).
* `--log-file <файл>`: Путь к файлу, в который будут записываться логи клиента (по умолчанию: `client.log`).
* `-h, --help`: Показать справочную информацию по всем доступным опциям и выйти.

**Пример запуска клиента в интерактивном режиме:**
(Подключается к серверу на `localhost`, порт `12345`)
```bash
./bin/database_client -s localhost -p 12345
```

После подключения вы увидите приглашение [localhost:12345] >. Вводите команды (например, HELP, PRINT_ALL END, EXIT). Для выхода из клиента используйте команду QUIT_CLIENT.

Пример запуска клиента в пакетном режиме:
(Предполагается, что сервер запущен, и файл queries_client_example.txt существует в директории data относительно корня проекта)

Bash

./bin/database_client -s localhost -f ../../data/queries_client_example.txt -o client_session_results.txt --timeout 10000
Результаты выполнения команд будут сохранены в client_session_results.txt.

6.5. Запуск Генератора Данных
Утилита generate_data используется для создания файлов с тестовыми данными для базы.

Перейдите в директорию <корневая_директория_проекта>/build/bin/.
Запустите генератор:
Bash

./generate_data <количество_записей> <выходной_файл> [макс_трафик_ГБ] [начальный_год] [конечный_год]
<количество_записей>: Целое положительное число.
<выходной_файл>: Путь к файлу, в который будут сохранены сгенерированные записи.
[макс_трафик_ГБ] (опционально): Максимальное значение трафика в ГБ для одного часа (по умолчанию: 10.0).
[начальный_год] (опционально): Начальный год для генерации дат (по умолчанию: 2022).
[конечный_год] (опционально): Конечный год для генерации дат (по умолчанию: текущий год).
Пример использования генератора:

Bash

./bin/generate_data 1000 ../../data/generated_provider_data_1k.txt 15.0 2023 2024
Это создаст файл generated_provider_data_1k.txt в директории data (относительно корня проекта) с 1000 записей.

6.6. Запуск Модульных Тестов
Модульные тесты проверяют корректность работы отдельных компонентов системы (классов, функций).

Убедитесь, что проект успешно собран (включая цель run_unit_tests).
Перейдите в директорию сборки (<корневая_директория_проекта>/build/).
Запустите тесты с помощью CTest:
Bash

ctest
# Для более подробного вывода:
# ctest -V 
# или
# ctest --verbose
Или можно напрямую запустить исполняемый файл тестов:
Bash

./bin/run_unit_tests
Результаты выполнения тестов будут выведены в консоль.
6.7. Генерация Документации
Если у вас установлен Doxygen и Graphviz (для диаграмм), и в CMakeLists.txt настроена цель doxygen:

Убедитесь, что проект успешно сконфигурирован CMake.
Перейдите в директорию сборки (<корневая_директория_проекта>/build/).
Выполните команду для генерации документации:
Bash

make doxygen
# или, если вы используете Ninja:
# ninja doxygen
HTML-документация будет сгенерирована в директории, указанной в конфигурации Doxygen (обычно это build/doxygen_docs/html/). Откройте файл index.html в веб-браузере.
6.8. Анализ Покрытия Кода (для Debug-сборки с GCC/Clang)
Эта процедура позволяет оценить, какая часть исходного кода покрыта модульными (и, возможно, интеграционными) тестами.

Соберите проект в Debug-режиме с включенной опцией ENABLE_COVERAGE:
Bash

cd <корневая_директория_проекта>/build
cmake .. -DCMAKE_BUILD_TYPE=Debug -DENABLE_COVERAGE=ON
cmake --build .
Запустите тесты. Это необходимо для того, чтобы сгенерировались файлы с данными о покрытии (.gcda).
Bash

ctest 
# или ./bin/run_unit_tests
# Для более полного покрытия рекомендуется также запустить интеграционные тесты, 
# если они взаимодействуют с кодом, покрытие которого вы хотите измерить.
Сгенерируйте отчет о покрытии. В CMakeLists.txt должна быть настроена цель coverage.
Bash

make coverage
# или
# ninja coverage
HTML-отчет о покрытии кода будет доступен в директории build/coverage_report/html_total/. Откройте файл index.html в веб-браузере для просмотра детальной информации.
